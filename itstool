#!/usr/bin/env python

import gettext
import libxml2
import optparse
import os
import re
import sys

NS_ITS = 'http://www.w3.org/2005/11/its'
NS_ITST = 'http://example.com/itstool/'
NS_BLANK = 'http://example.com/itstool/blank/'


class NoneTranslations:
    def gettext(self, message):
        return None

    def lgettext(self, message):
        return None

    def ngettext(self, msgid1, msgid2, n):
        return None

    def lngettext(self, msgid1, msgid2, n):
        return None

    def ugettext(self, message):
        return None

    def ungettext(self, msgid1, msgid2, n):
        return None


class MessageList (object):
    def __init__ (self):
        self._messages = []
        self._by_node = {}

    def add_message (self, message, node):
        self._messages.append (message)
        self._by_node[node] = message

    def get_message_by_node (self, node):
        return self._by_node.get(node, None)

    def output (self, out):
        msgs = []
        msgdict = {}
        for msg in self._messages:
            key = (msg.get_context(), msg.get_string())
            if msgdict.has_key(key):
                for source in msg.get_sources():
                    msgdict[key].add_source(source)
            else:
                msgs.append(msg)
                msgdict[key] = msg
        for msg in msgs:
            out.write(msg.format().encode('utf-8'))
            out.write('\n')


class Message (object):
    def __init__ (self):
        self._message = []
        self._empty = True
        self._ctxt = None
        self._placeholders = []
        self._sources = []
        self._preserve = False

    class Placeholder (object):
        def __init__ (self, node):
            self.node = node
            self.name = node.name

    def escape (self, text):
        return text.replace('\\','\\\\').replace('"', "\\\"").replace("\n","\\n").replace("\t","\\t")

    def add_text (self, text):
        if len(self._message) == 0 or not(isinstance(self._message[-1], basestring)):
            self._message.append('')
        self._message[-1] += text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
        if re.sub('\s+', ' ', text).strip() != '':
            self._empty = False

    def add_placeholder (self, node):
        holder = Message.Placeholder(node)
        self._placeholders.append(holder)
        self._message.append(holder)

    def get_placeholder (self, name):
        placeholder = 1
        for holder in self._placeholders:
            holdername = '%s-%i' % (holder.name, placeholder)
            if holdername == name:
                return holder
            placeholder += 1

    def add_start_tag (self, node):
        if len(self._message) == 0 or not(isinstance(self._message[-1], basestring)):
            self._message.append('')
        self._message[-1] += ('<%s' % node.name)
        if node.properties is not None:
            for prop in node.properties:
                if prop.type == 'attribute':
                    name = prop.name
                    if prop.ns() is not None:
                        name = prop.ns().name + ':' + name
                    atval = prop.content
                    atval = atval.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;')
                    self._message += " %s=\"%s\"" % (name, atval)
        if node.children is not None:
            self._message[-1] += '>'
        else:
            self._message[-1] += '/>'

    def add_end_tag (self, node):
        if node.children is not None:
            if len(self._message) == 0 or not(isinstance(self._message[-1], basestring)):
                self._message.append('')
            self._message[-1] += ('</%s>' % node.name)

    def is_empty (self):
        return self._empty

    def get_context (self):
        return self._ctxt

    def set_context (self, ctxt):
        self._ctxt = ctxt

    def add_source (self, source):
        self._sources.append(source)

    def get_sources (self):
        return self._sources

    def get_string (self):
        message = ''
        placeholder = 1
        for msg in self._message:
            if isinstance(msg, basestring):
                message += msg
            elif isinstance(msg, Message.Placeholder):
                message += '<_:%s-%i/>' % (msg.name, placeholder)
                placeholder += 1
        if not self._preserve:
            message = re.sub('\s+', ' ', message).strip()
        return message.decode('utf-8')

    def preserve_space (self):
        self._preserve = True

    def format (self):
        ret = ''
        for source in self._sources:
            ret += '#: %s\n' % source
        if self._preserve:
            ret += '#, no-wrap\n'
        if self._ctxt is not None:
            ret += 'msgctxt "%s"\n' % self._ctxt
        message = self.get_string()
        if self._preserve:
            ret += 'msgid ""\n'
            lines = message.split('\n')
            for line, no in zip(lines, range(len(lines))):
                if no == len(lines) - 1:
                    ret += '"%s"\n' % self.escape(line)
                else:
                    ret += '"%s\\n"\n' % self.escape(line)
        else:
            ret += 'msgid "%s"\n' % self.escape(message)
        ret += 'msgstr ""\n'
        return ret


def xml_child_iter (node):
    child = node.children
    while child is not None:
        yield child
        child = child.next

def xml_is_ns_name (node, ns, name):
    if node.type != 'element':
        return False
    return node.name == name and node.ns().content == ns


class Document (object):
    def __init__ (self, filename, messages):
        ctxt = libxml2.createFileParserCtxt(filename)
        ctxt.lineNumbers(1)
        ctxt.replaceEntities(1)
        ctxt.parseDocument()
        self._doc = ctxt.doc()
        self._localrules = []
        def pre_process (node):
            for child in xml_child_iter(node):
                if xml_is_ns_name(child, 'http://www.w3.org/2001/XInclude', 'include'):
                    if child.prop('parse') == 'text':
                        child.xincludeProcessTree()
                elif xml_is_ns_name(child, NS_ITS, 'rules'):
                    self._localrules.append(child)
                pre_process(child)
        pre_process(self._doc)
        self._msgs = messages
        self._its_translate_nodes = {}
        self._its_within_text_nodes = {}
        self._itst_preserve_space_nodes = {}

    def apply_its_rule(self, rule, xpath):
        if rule.type != 'element':
            return
        if xml_is_ns_name(rule, NS_ITS, 'translateRule'):
            if rule.prop('selector') is not None:
                for node in xpath.xpathEval(rule.prop('selector')):
                    self._its_translate_nodes[node] = rule.prop('translate')
        elif xml_is_ns_name(rule, NS_ITS, 'withinTextRule'):
            if rule.prop('selector') is not None:
                for node in xpath.xpathEval(rule.prop('selector')):
                    self._its_within_text_nodes[node] = rule.prop('withinText')
        elif xml_is_ns_name(rule, NS_ITST, 'preserveSpaceRule'):
            if rule.prop('selector') is not None:
                for node in xpath.xpathEval(rule.prop('selector')):
                    self._itst_preserve_space_nodes[node] = rule.prop('preserveSpace')

    def apply_its_rules (self):
        dirs = []
        ddir = os.getenv('XDG_DATA_HOME', '')
        if ddir == '':
            ddir = os.path.join(os.path.expanduser('~'), '.local', 'share')
        dirs.append(ddir)
        ddir = os.getenv('XDG_DATA_DIRS', '')
        if ddir == '':
            ddir = '/usr/local/share:/usr/share'
        dirs.extend(ddir.split(':'))
        ddone = {}
        for ddir in dirs:
            itsdir = os.path.join(ddir, 'itstool', 'its')
            if not os.path.exists(itsdir):
                continue
            for dfile in os.listdir(itsdir):
                if dfile.endswith('.its'):
                    if not ddone.get(dfile, False):
                        self.apply_its_file(os.path.join(itsdir, dfile))
                        ddone[dfile] = True
        self.apply_local_its_rules()

    def apply_its_file (self, filename):
        doc = libxml2.parseFile(filename)
        xpath = self._doc.xpathNewContext()
        for root in xml_child_iter(doc):
            if xml_is_ns_name(root, NS_ITS, 'rules'):
                break
        if root is None:
            return
        nsdef = root.nsDefs()
        while nsdef is not None:
            if nsdef.name is not None:
                xpath.xpathRegisterNs(nsdef.name, nsdef.content)
            nsdef = nsdef.next
        for rule in xml_child_iter(root):
            nsdef = rule.nsDefs()
            if nsdef is not None:
                rule_xpath = self._doc.xpathNewContent()
                nsdef = root.nsDefs()
                while nsdef is not None:
                    if nsdef.name is not None:
                        xpath.xpathRegisterNs(nsdef.name, nsdef.content)
                    nsdef = nsdef.next
                nsdef = rule.nsDefs()
                while nsdef is not None:
                    if nsdef.name is not None:
                        xpath.xpathRegisterNs(nsdef.name, nsdef.content)
                    nsdef = nsdef.next
            else:
                rule_xpath = xpath
            self.apply_its_rule(rule, rule_xpath)

    def apply_local_its_rules (self):
        for rules in self._localrules:
            def reg_ns(xpath, node):
                if node.parent is not None:
                    reg_ns(xpath, node.parent)
                nsdef = node.nsDefs()
                while nsdef is not None:
                    if nsdef.name is not None:
                        xpath.xpathRegisterNs(nsdef.name, nsdef.content)
                    nsdef = nsdef.next
            xpath = self._doc.xpathNewContext()
            reg_ns(xpath, rules)
            for rule in xml_child_iter(rules):
                if rule.nsDefs() is not None:
                    rule_xpath = self._doc.xpathNewContent()
                    reg_ns(rule_xpath, rule)
                else:
                    rule_xpath = xpath
                self.apply_its_rule(rule, rule_xpath)

    def merge_translations (self, translations, node=None):
        if node is None:
            self.generate_messages()
            node = self._doc.getRootElement()
        if node is None or node.type != 'element':
            return
        msg = self._msgs.get_message_by_node(node)
        if msg is None:
            children = [child for child in xml_child_iter(node)]
            for child in children:
                self.merge_translations(translations, node=child)
        else:
            newnode = self.get_translated(node, translations)
            if newnode != node:
                node.replaceNode(newnode)

    def get_translated (self, node, translations):
        msg = self._msgs.get_message_by_node(node)
        if msg is None:
            return node
        trans = translations.ugettext(msg.get_string())
        if trans is None:
            return node
        nss = {}
        def reg_ns(node, nss):
            if node.parent is not None:
                reg_ns(node.parent, nss)
            nsdef = node.nsDefs()
            while nsdef is not None:
                if nsdef.name is not None:
                    nss[nsdef.name] = nsdef.content
                nsdef = nsdef.next
        reg_ns(node, nss)
        nss['_'] = NS_BLANK
        blurb = '<' + node.name
        for nsname in nss.keys():
            blurb += ' xmlns:%s="%s"' % (nsname, nss[nsname])
        blurb += '>%s</%s>' % (trans.encode('utf-8'), node.name)
        ctxt = libxml2.createDocParserCtxt(blurb)
        ctxt.replaceEntities(0)
        ctxt.parseDocument()
        trnode = ctxt.doc().getRootElement()
        def scan_node(node):
            for child in xml_child_iter(node):
                if child.type != 'element':
                    continue
                if child.ns() is not None and child.ns().content == NS_BLANK:
                    repl = self.get_translated(msg.get_placeholder(child.name).node, translations)
                    child.replaceNode(repl)
                scan_node(child)
        scan_node(trnode)
        retnode = node.copyNode(2)
        for child in xml_child_iter(trnode):
            retnode.addChild(child.copyNode(1))
        return retnode

    def generate_messages (self):
        for child in xml_child_iter(self._doc):
            if child.type == 'element':
                self.generate_message (child, None)
                break

    def generate_message (self, node, msg):
        if node.type in ('text', 'cdata') and msg is not None:
            msg.add_text(node.content)
            return
        if node.type != 'element':
            return
        if self.get_its_translate(node) != 'yes':
            if msg is not None:
                msg.add_placeholder(node)
            return
        is_unit = msg is None or self.is_translation_unit(node)
        if is_unit:
            if msg is not None:
                msg.add_placeholder(node)
            msg = Message()
            if self.get_preserve_space(node):
                msg.preserve_space()
            msg.add_source('%s:%i(%s/%s)' % (self._doc.name, node.lineNo(), node.parent.name, node.name))
        else:
            msg.add_start_tag(node)
        for child in xml_child_iter(node):
            self.generate_message(child, msg)
        if is_unit and not msg.is_empty():
            self._msgs.add_message(msg, node)
        else:
            msg.add_end_tag(node)

    def is_translation_unit (self, node):
        return self.get_its_within_text(node) != 'yes'

    def get_preserve_space (self, node):
        if node.getSpacePreserve() == 1:
            return True
        else:
            while node.type == 'element':
                if self._itst_preserve_space_nodes.has_key(node):
                    return (self._itst_preserve_space_nodes[node] == 'yes')
                node = node.parent
        return False

    def get_its_translate (self, node):
        while node.type == 'element':
            if node.hasNsProp('translate', NS_ITS):
                return node.nsProp('translate', NS_ITS)
            if self._its_translate_nodes.has_key(node):
                return self._its_translate_nodes[node]
            node = node.parent
        return 'yes'

    def get_its_within_text (self, node):
        return self._its_within_text_nodes.get(node, 'no')


if __name__ == '__main__':
    options = optparse.OptionParser()
    options.add_option('-m',
                       dest='merge',
                       metavar='FILE',
                       help='merge from a PO or MO file FILE and output XML files')
    options.add_option('-o',
                       dest='output',
                       default='-',
                       metavar='OUT',
                       help='output PO files to file OUT or XML files in directory OUT')
    (opts, args) = options.parse_args(sys.argv)

    if opts.merge is None:
        messages = MessageList()
        for filename in args[1:]:
            doc = Document(filename, messages)
            doc.apply_its_rules()
            doc.generate_messages()
        if opts.output == '-':
            out = sys.stdout
        else:
            out = file(opts.output, 'w')
        messages.output(out)
    else:
        translations = gettext.GNUTranslations(open(opts.merge, 'rb'))
        translations.add_fallback(NoneTranslations())
        if opts.output == '-':
            out = sys.stdout
        elif os.path.isdir(opts.output):
            out = opts.output
        elif len(args) == 2:
            out = file(opts.output, 'w')
        else:
            sys.stderr.write('Error: Non-directory output for multiple files\n')
            sys.exit(1)
        for filename in args[1:]:
            messages = MessageList()
            doc = Document(filename, messages)
            doc.apply_its_rules()
            doc.merge_translations(translations)
            fout = out
            if isinstance(fout, basestring):
                fout = file(os.path.join(fout, os.path.basename(filename)), 'w')
            fout.write(doc._doc.serialize('utf-8'))
